from flask import Flask, render_template, request, redirect, url_for, flash, session
import os
import uuid
import hashlib
from werkzeug.utils import secure_filename
from werkzeug.exceptions import RequestEntityTooLarge
from datetime import datetime
from utils.scanner import scan_file
from utils.validators import allowed_file
from config import Config

app = Flask(__name__)
app.config.from_object(Config)

# Ensure upload folder exists
os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
os.makedirs(app.config['SCAN_RESULTS'], exist_ok=True)

@app.route('/')
def index():
    """Home page route"""
    return render_template('index.html')

@app.route('/about')
def about():
    """About page route"""
    return render_template('about.html')

@app.route('/upload', methods=['GET', 'POST'])
def upload_file():
    """Handle file upload and scanning"""
    if request.method == 'GET':
        # Se o método for GET, redirecione para a página inicial
        return redirect(url_for('index'))
        
    try:
        if 'file' not in request.files:
            flash('Nenhum arquivo selecionado', 'error')
            return redirect(url_for('index'))
        
        file = request.files['file']
        
        if file.filename == '':
            flash('Nenhum arquivo selecionado', 'error')
            return redirect(url_for('index'))
        
        if file and allowed_file(file.filename):
            # Generate unique filename
            original_filename = secure_filename(file.filename)
            file_extension = os.path.splitext(original_filename)[1]
            unique_filename = f"{uuid.uuid4().hex}{file_extension}"
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], unique_filename)
            
            # Garantir que o diretório de upload exista
            os.makedirs(os.path.dirname(file_path), exist_ok=True)
            
            # Salvar arquivo
            file.save(file_path)
            
            # Calcular hash do arquivo (SHA-256)
            file_hash = calculate_file_hash(file_path)
            
            # Imprimir informações de diagnóstico
            print(f"DEBUG - Arquivo recebido: {original_filename}, salvo como: {unique_filename}")
            print(f"DEBUG - Tamanho do arquivo: {os.path.getsize(file_path)} bytes")
            print(f"DEBUG - Hash SHA-256: {file_hash}")
            
            # Escanear arquivo em busca de ameaças
            scan_results = scan_file(file_path, original_filename)
            
            # Verificar se o scan_results tem a estrutura esperada
            if not isinstance(scan_results, dict):
                print(f"ERRO - scan_results não é um dicionário: {type(scan_results)}")
                flash('Erro ao analisar o arquivo: formato de resultado inválido', 'error')
                return redirect(url_for('index'))
                
            if 'summary' not in scan_results or 'engines' not in scan_results:
                print(f"ERRO - scan_results não contém as chaves esperadas: {scan_results.keys()}")
                flash('Erro ao analisar o arquivo: dados incompletos', 'error')
                return redirect(url_for('index'))
            
            # Salvar resultados da análise
            result_id = save_scan_results(file_hash, original_filename, scan_results)
            
            # Armazenar ID do resultado na sessão
            session['last_scan_id'] = result_id
            
            print(f"DEBUG - Análise concluída. ID do resultado: {result_id}")
            
            return redirect(url_for('show_result', scan_id=result_id))
        else:
            flash('Tipo de arquivo não permitido', 'error')
            return redirect(url_for('index'))
    
    except RequestEntityTooLarge:
        flash('O arquivo excede o tamanho máximo permitido', 'error')
        return redirect(url_for('index'))
    
    except Exception as e:
        import traceback
        print(f"ERRO ao processar arquivo: {str(e)}")
        print(traceback.format_exc())
        flash(f'Erro ao processar o arquivo: {str(e)}', 'error')
        return redirect(url_for('index'))
        
@app.route('/result/<scan_id>')
def show_result(scan_id):
    """Display scan results with diagnostic information"""
    # Load result data from stored results
    import os
    import json
    from flask import current_app, render_template, flash, redirect, url_for
    
    # Certifique-se de que o diretório de resultados existe
    results_dir = current_app.config['SCAN_RESULTS']
    os.makedirs(results_dir, exist_ok=True)
    
    result_file = os.path.join(results_dir, f"{scan_id}.json")
    
    if not os.path.exists(result_file):
        print(f"DEBUG - Arquivo de resultado não encontrado: {result_file}")
        flash('Resultado de análise não encontrado', 'error')
        return redirect(url_for('index'))
    
    try:
        with open(result_file, 'r') as f:
            result_data = json.load(f)
        
        # Debug - imprime a estrutura do objeto
        print(f"DEBUG - Result data contém as chaves: {result_data.keys()}")
        if 'summary' in result_data:
            print(f"DEBUG - Summary contém: {result_data['summary'].keys()}")
        if 'engines' in result_data:
            print(f"DEBUG - Número de engines: {len(result_data['engines'])}")
            print(f"DEBUG - Exemplo de engine: {next(iter(result_data['engines'].items()))}")
        
        # Verificação adicional para garantir que todas as chaves necessárias existam
        required_keys = ['scan_id', 'timestamp', 'file', 'summary', 'engines']
        missing_keys = [key for key in required_keys if key not in result_data]
        
        if missing_keys:
            print(f"AVISO - Chaves ausentes no resultado: {missing_keys}")
            # Adicionar chaves ausentes com valores vazios para evitar erros no template
            for key in missing_keys:
                if key == 'summary':
                    result_data[key] = {
                        "scan_date": "Data não disponível",
                        "file_name": result_data.get('file', {}).get('name', "Nome não disponível"),
                        "file_size": 0,
                        "total_engines": 0,
                        "detected_threats": 0,
                        "clean_engines": 0,
                        "error_engines": 0,
                        "risk_assessment": {
                            "level": "Indeterminado",
                            "color": "gray",
                            "detection_rate": "0/0 (0%)"
                        }
                    }
                elif key == 'engines':
                    result_data[key] = {}
                elif key == 'file':
                    result_data[key] = {"name": "Nome não disponível", "sha256": "Hash não disponível"}
                elif key == 'scan_id':
                    result_data[key] = scan_id
                elif key == 'timestamp':
                    result_data[key] = "Data não disponível"
        
        return render_template('result.html', result=result_data)
    except Exception as e:
        print(f"ERRO ao carregar resultado: {str(e)}")
        flash(f'Erro ao carregar os resultados: {str(e)}', 'error')
        return redirect(url_for('index'))
# Funções corrigidas para scan_file e save_scan_results em app.py

def scan_file(file_path, original_filename):
    """
    Scan file for threats using multiple scanning engines
    In a production environment, this would integrate with actual AV engines
    """
    # Lista de engines de escaneamento
    scanning_engines = [
        "Acronis (Static ML)", "AhnLab-V3", "AliCloud", "ALYac", "Antiy-AVL",
        "Arcabit", "Arctic Wolf", "Avast", "AVG", "Avira (no cloud)",
        "Baidu", "BitDefender", "Bkav Pro", "ClamAV", "CMC",
        "CrowdStrike Falcon", "CTX", "Cynet", "DrWeb", "Emsisoft",
        "eScan", "ESET-NOD32", "Fortinet", "GData", "Google",
        "Gridinsoft (no cloud)", "Huorong", "Ikarus", "Jiangmin", "K7AntiVirus",
        "K7GW", "Kaspersky", "Kingsoft", "Lionic", "Malwarebytes",
        "MaxSecure", "Microsoft", "NANO-Antivirus", "Panda", "QuickHeal",
        "Rising", "Sangfor Engine Zero", "SentinelOne (Static ML)", "Skyhigh (SWG)", "Sophos",
        "SUPERAntiSpyware", "Symantec", "TACHYON", "Tencent", "Trellix (ENS)",
        "TrendMicro", "TrendMicro-HouseCall", "Varist", "VBA32", "VIPRE",
        "VirIT", "ViRobot", "WithSecure", "Xcitium", "Yandex",
        "Zillya", "ZoneAlarm by Check Point", "Zoner", "Alibaba", "Avast-Mobile",
        "BitDefenderFalx", "DeepInstinct", "Elastic", "McAfee Scanner", "Palo Alto Networks",
        "SecureAge", "Symantec Mobile Insight", "TEHTRIS", "Trapmine", "Trustlook",
        "Webroot"
    ]

    # Tentar usar ClamAV se disponível
    clam_result = None
    try:
        # Verificar se o ClamAV está instalado e tentar usá-lo
        import subprocess
        clam_result = subprocess.run(['clamscan', '--no-summary', file_path], 
                                    capture_output=True, text=True, timeout=60)
        if clam_result.returncode == 0:
            clam_detected = "Clean"
        elif clam_result.returncode == 1:
            clam_detected = "Infected"
        else:
            clam_detected = "Error"
    except Exception:
        # ClamAV não disponível ou erro ocorrido
        clam_detected = "Not available"
    
    # Simular resultados para outros engines
    import random
    import os
    from datetime import datetime
    
    scan_results = {
        "summary": {
            "scan_date": datetime.now().isoformat(),
            "file_name": original_filename,
            "file_size": os.path.getsize(file_path),
            "total_engines": len(scanning_engines),
            "detected_threats": 0,
            "clean_engines": 0,
            "error_engines": 0
        },
        "engines": {}
    }
    
    # Simular escaneamento com cada engine
    for engine in scanning_engines:
        # Caso especial para ClamAV se realmente o executamos
        if engine == "ClamAV" and clam_result is not None:
            result = {
                "status": "completed",
                "result": clam_detected,
                "threat_name": "" if clam_detected == "Clean" else "Simulated.Threat.Demo",
                "scan_time": random.uniform(0.5, 3.0)
            }
        else:
            # Simular resultados de escaneamento aleatórios
            status_options = ["completed", "completed", "completed", "error", "timeout"]
            result_options = ["Clean", "Clean", "Clean", "Clean", "Infected"]
            
            status = random.choice(status_options)
            if status == "completed":
                result_value = random.choice(result_options)
                
                result = {
                    "status": status,
                    "result": result_value,
                    "threat_name": "" if result_value == "Clean" else f"Simulated.Threat.{random.randint(1000, 9999)}",
                    "scan_time": random.uniform(0.5, 3.0)
                }
                
                # Atualizar contagens de resumo
                if result_value == "Clean":
                    scan_results["summary"]["clean_engines"] += 1
                else:
                    scan_results["summary"]["detected_threats"] += 1
            else:
                result = {
                    "status": status,
                    "result": "Unknown",
                    "threat_name": "",
                    "scan_time": random.uniform(0.1, 1.0)
                }
                scan_results["summary"]["error_engines"] += 1
        
        scan_results["engines"][engine] = result
    
    # Adicionar avaliação de risco geral simulada
    detected = scan_results["summary"]["detected_threats"]
    total = scan_results["summary"]["total_engines"] - scan_results["summary"]["error_engines"]
    
    if detected == 0:
        risk_level = "Limpo"
        risk_color = "green"
    elif detected / total < 0.05:
        risk_level = "Baixo Risco"
        risk_color = "yellow"
    elif detected / total < 0.15:
        risk_level = "Risco Moderado"
        risk_color = "orange"
    else:
        risk_level = "Alto Risco"
        risk_color = "red"
    
    scan_results["summary"]["risk_assessment"] = {
        "level": risk_level,
        "color": risk_color,
        "detection_rate": f"{detected}/{total} ({(detected/total)*100:.1f}%)"
    }
    
    return scan_results

def save_scan_results(file_hash, original_filename, scan_results):
    """Salvar os resultados da digitalização em um arquivo JSON"""
    import json
    import uuid
    import os
    from flask import current_app
    from datetime import datetime
    
    # Criar ID único para este escaneamento
    scan_id = uuid.uuid4().hex
    
    # Preparar estrutura de dados
    result_data = {
        "scan_id": scan_id,
        "timestamp": datetime.now().isoformat(),
        "file": {
            "name": original_filename,
            "sha256": file_hash
        },
        "summary": scan_results["summary"],
        "engines": scan_results["engines"]
    }
    
    # Verificar se o diretório de resultados existe
    results_dir = current_app.config['SCAN_RESULTS']
    os.makedirs(results_dir, exist_ok=True)
    
    # Salvar em arquivo
    result_file = os.path.join(results_dir, f"{scan_id}.json")
    
    # Imprimir debug para verificar a estrutura antes de salvar
    print(f"DEBUG - Salvando resultado com as chaves: {result_data.keys()}")
    print(f"DEBUG - Estrutura summary: {result_data['summary'].keys() if 'summary' in result_data else 'Não presente'}")
    print(f"DEBUG - Número de engines: {len(result_data['engines']) if 'engines' in result_data else 'Não presente'}")
    
    try:
        with open(result_file, 'w') as f:
            json.dump(result_data, f, indent=2)
        print(f"DEBUG - Arquivo de resultado salvo com sucesso: {result_file}")
        
        # Verificar se o arquivo foi criado corretamente
        if os.path.exists(result_file):
            with open(result_file, 'r') as f:
                saved_data = json.load(f)
                print(f"DEBUG - Verificação: arquivo contém as chaves: {saved_data.keys()}")
    except Exception as e:
        print(f"ERRO ao salvar resultado: {str(e)}")
        # Em caso de erro, tentar salvar uma versão simplificada
        try:
            simplified_data = {
                "scan_id": scan_id,
                "timestamp": datetime.now().isoformat(),
                "file": {"name": original_filename, "sha256": file_hash},
                "error": "Erro ao salvar dados completos"
            }
            with open(result_file, 'w') as f:
                json.dump(simplified_data, f)
            print("DEBUG - Versão simplificada salva como fallback")
        except:
            print("ERRO CRÍTICO: Não foi possível salvar nem a versão simplificada")
    
    return scan_id

def calculate_file_hash(file_path):
    """Calculate SHA-256 hash of a file"""
    sha256_hash = hashlib.sha256()
    
    with open(file_path, "rb") as f:
        for byte_block in iter(lambda: f.read(4096), b""):
            sha256_hash.update(byte_block)
    
    return sha256_hash.hexdigest()

def save_scan_results(file_hash, original_filename, scan_results):
    """Save scan results to a JSON file"""
    import json
    
    # Create unique ID for this scan
    scan_id = uuid.uuid4().hex
    
    # Prepare data structure
    result_data = {
        "scan_id": scan_id,
        "timestamp": datetime.now().isoformat(),
        "file": {
            "name": original_filename,
            "sha256": file_hash
        },
        "results": scan_results
    }
    
    # Save to file
    result_file = os.path.join(app.config['SCAN_RESULTS'], f"{scan_id}.json")
    with open(result_file, 'w') as f:
        json.dump(result_data, f, indent=2)
    
    return scan_id

if __name__ == '__main__':
    app.run(debug=app.config['DEBUG'], host='0.0.0.0', port=app.config['PORT'])
